# Ontology-Driven Parser Generation

This document explains how the Actions parser is automatically generated from the ontology.

## Architecture

```
https://clearhead.us/vocab/actions/v3     (Production V3 ontology - domain semantics)
    ↓ imports via HTTP
parser-ontology.ttl                        (Syntax annotations - parser-specific)
    ↓ JavaScript parses
syntax_mapping.json                        (GENERATED - intermediate format)
    ↓ JavaScript templates
grammar.js                                 (GENERATED - tree-sitter DSL)
    ↓ tree-sitter compiles
parser.c                                   (Final parser binary)
```

## Key Principle: Independence

The parser repo is **fully independent** of the ontology repo:
- ✅ Fetches V3 ontology from published URL (no local coupling)
- ✅ All generation happens in JavaScript (no Python dependency)
- ✅ Parser-specific metadata lives in `parser-ontology.ttl` (clean separation)
- ✅ Can be cloned and built standalone

The ontology repo is **unaware** of parser implementation:
- ✅ Publishes semantic vocabulary only
- ✅ No parser-specific code or config
- ✅ Clean domain model

## Files

### Source Files (Hand-Maintained)

**`parser-ontology.ttl`** - Parser extension ontology
- Imports V3 from `https://clearhead.us/vocab/actions/v3`
- Adds syntax annotations to V3 properties:
  - `parser:symbol` - Character that introduces property (!, +, @, etc.)
  - `parser:grammarRuleName` - Tree-sitter rule name
  - `parser:ruleType` - Type of grammar rule (choice, pattern, etc.)
  - `parser:contextLevel` - Where property appears (root_only, any_level)
  - `parser:formatHint` - Human documentation
  - `parser:example` - Usage example
- Defines value mappings (e.g., DAILY → D for recurrence)
- Defines state-to-bracket mappings ([x] for completed)

**Example:**
```turtle
actions:hasPriority
    parser:symbol "!" ;
    parser:grammarRuleName "priority" ;
    parser:ruleType "choice" ;
    parser:contextLevel "any_level" ;
    parser:formatHint "Eisenhower matrix: 1=urgent+important, 4=neither" ;
    parser:example "!2" .
```

### Generated Files (Auto-Generated)

**`syntax_mapping.json`** - Intermediate mapping format
- Generated by: `npm run generate:mapping`
- Source: `parser-ontology.ttl` + (future: SHACL shapes from web)
- Contains:
  - Property → symbol mappings
  - Rule types and constraints
  - State mappings
  - Value transformations
  - Metadata about generation

**`grammar.js`** - Tree-sitter grammar (future)
- Generated by: `npm run generate:grammar`
- Source: `syntax_mapping.json`
- Tree-sitter DSL defining parser rules

## Generation Pipeline

### 1. Generate Syntax Mapping

```bash
npm run generate:mapping
```

This runs `scripts/generate-syntax-mapping.js`:
1. Loads `parser-ontology.ttl` (local file)
2. Extracts all `parser:*` annotations
3. (Future) Fetches SHACL shapes from web for constraints
4. Generates `syntax_mapping.json`

**Output:**
```json
{
  "metadata": {
    "generated_from": "parser-ontology.ttl",
    "imports": "https://clearhead.us/vocab/actions/v3",
    "version": "1.0.0"
  },
  "properties": {
    "hasPriority": {
      "symbol": "!",
      "rule_type": "choice",
      "grammar_rule_name": "priority",
      "values": ["1", "2", "3", "4"],
      ...
    }
  },
  "state_mappings": {
    "Completed": "x",
    "NotStarted": " ",
    ...
  }
}
```

### 2. Generate Grammar (Future)

```bash
npm run generate:grammar
```

This will run `src/grammar_generator.js`:
1. Loads `syntax_mapping.json`
2. Templates out tree-sitter rules
3. Generates `grammar.js`

### 3. Build Parser

```bash
npm run build:parser
```

This runs tree-sitter to compile the grammar:
1. `tree-sitter generate` - Generates parser C code from grammar.js
2. `tree-sitter build` - Compiles C code to binary

### One Command

```bash
npm run generate && npm run build:parser
```

## Workflow: Adding a New Property

Let's say V3 ontology adds a new property `actions:hasUrgency`.

### Step 1: Update parser-ontology.ttl

Add syntax annotations:

```turtle
actions:hasUrgency
    parser:symbol "^" ;
    parser:grammarRuleName "urgency" ;
    parser:ruleType "choice" ;
    parser:contextLevel "any_level" ;
    parser:formatHint "Urgency level: 1=low, 5=critical" ;
    parser:example "^3" .
```

### Step 2: Regenerate

```bash
npm run generate        # Regenerates mapping + grammar
npm run build:parser   # Rebuilds parser
npm test               # Verify tests pass
```

### Step 3: Done!

The parser now supports `^3` syntax for urgency.

## Workflow: Modifying Existing Syntax

Let's say we want to change priority symbol from `!` to `!!`.

### Step 1: Update parser-ontology.ttl

```turtle
actions:hasPriority
    parser:symbol "!!" ;    # Changed from "!"
    ...
```

### Step 2: Regenerate

```bash
npm run generate && npm run build:parser
```

### Step 3: Update Tests

Update test fixtures to use `!!` instead of `!`.

## Benefits

### For Development

- **Single source of truth** - Syntax defined once in ontology
- **Automatic propagation** - Changes flow through pipeline
- **No manual sync** - Mapping, grammar, parser all regenerated
- **Type safety** - (Future) Generate TypeScript types from same ontology

### For Documentation

- **Self-documenting** - `formatHint` and `example` in ontology
- **Always accurate** - Docs generated from same source as parser
- **Semantic clarity** - Link syntax to domain model

### For Interoperability

- **Standards-based** - Uses published W3C vocabulary
- **Tool-agnostic** - Other tools can parse same ontology
- **Version tracking** - Ontology version ties to parser version

## Future Enhancements

### 1. Fetch SHACL Shapes from Web

Currently, SHACL constraints (min/max values, patterns) are hardcoded in the generator.

**Goal:** Fetch `https://clearhead.us/vocab/actions/v3/shapes.ttl` and extract:
- `sh:minInclusive` / `sh:maxInclusive` → `values` for choice rules
- `sh:pattern` → regex patterns
- `sh:in` → enum values
- `sh:minCount` → required properties

**Implementation:**
- Add turtle parser or use `n3.js` library
- Parse SHACL shapes
- Merge with parser annotations

### 2. Full Grammar Generation

Currently, `grammar.js` is hand-written. Future goal: generate it entirely.

**Implementation:**
- Template engine in `src/grammar_generator.js`
- Convert syntax_mapping rule types → tree-sitter DSL
- Handle special patterns (brackets, depth markers, lists)

### 3. TypeScript Type Generation

Generate TypeScript types for AST nodes from same ontology.

**Implementation:**
- Read `syntax_mapping.json`
- Generate TS interfaces matching parser nodes
- Use with `type-sitter` for full type safety

### 4. Multi-Format Support

Generate parsers for other formats (YAML, TOML) from same ontology.

**Implementation:**
- Different syntax annotations per format
- Shared semantic model
- Format-specific generation pipeline

## Troubleshooting

### Syntax mapping not updating after ontology change

```bash
# Force regeneration
rm syntax_mapping.json
npm run generate:mapping
```

### Generator failing to parse ontology

- Check `parser-ontology.ttl` syntax (valid Turtle)
- Ensure all annotations use correct `parser:` prefix
- Run: `rapper -i turtle parser-ontology.ttl` (if rapper installed)

### Want to see what changed

```bash
# Before changes
npm run generate:mapping
cp syntax_mapping.json syntax_mapping.old.json

# Make changes to parser-ontology.ttl

# After changes
npm run generate:mapping
diff syntax_mapping.old.json syntax_mapping.json
```

## References

- **V3 Ontology:** https://clearhead.us/vocab/actions/v3
- **File Format Spec:** [docs/actions-fileformat-spec.md](./docs/actions-fileformat-spec.md)
- **Parser Ontology:** [parser-ontology.ttl](./parser-ontology.ttl)
- **Syntax Mapping:** [syntax_mapping.json](./syntax_mapping.json) (generated)

## Contributing

When contributing parser changes:

1. **Don't edit generated files** (`syntax_mapping.json`, future `grammar.js`)
2. **Do edit source files** (`parser-ontology.ttl`)
3. **Always regenerate** after changes (`npm run generate`)
4. **Test thoroughly** (`npm test`)
5. **Document rationale** in git commit (why this syntax change?)

The parser is driven by the ontology. Change the ontology, the parser follows.
